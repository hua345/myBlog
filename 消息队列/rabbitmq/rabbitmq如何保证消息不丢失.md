# 如何保证消息的可靠性传输？

## 面试官心理分析
这个是肯定的，用 MQ 有个基本原则，就是数据不能多一条，也不能少一条，不能多，就是前面说的重复消费和幂等性问题。不能少，就是说这数据别搞丢了。那这个问题你必须得考虑一下。

如果说你这个是用 MQ 来传递非常核心的消息，比如说计费、扣费的一些消息，那必须确保这个 MQ 传递过程中绝对不会把计费消息给弄丢。

## 面试题剖析

数据的丢失问题，可能出现在生产者、MQ、消费者中，咱们从 RabbitMQ 和 Kafka 分别来分析一下吧。

消息发送成功分两种：

消息到达Broker
消息被成功路由到Queue
一般从业务角度来说，只有消息被路由到Queue中，才算真正的发送成功。

针对这两种情况，RabbitMQ提供了两种回调：ConfirmCallback和ReturnCallback。

## 生产者弄丢了数据

生产者将数据发送到 `RabbitMQ` 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。

此时可以选择用 `RabbitMQ` 提供的事务功能，就是生产者发送数据之前开启 `RabbitMQ` 事务 `channel.txSelect` ，然后发送消息，如果消息没有成功被 `RabbitMQ` 接收到，那么生产者会收到异常报错，此时就可以回滚事务 `channel.txRollback` ，然后重试发送消息；如果收到了消息，那么可以提交事务 `channel.txCommit` 。

```java
// 开启事务
channel.txSelect
try {
    // 这里发送消息
} catch (Exception e) {
    channel.txRollback

    // 这里再次重发这条消息
}
// 提交事务
channel.txCommit
```

但是问题是，RabbitMQ 事务机制（同步）一搞，基本上吞吐量会下来，因为太耗性能。

所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启 `confirm` 模式，在生产者那里设置开启 `confirm` 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 `RabbitMQ` `中，RabbitMQ` 会给你回传一个 ack 消息，告诉你说这个消息 ok 了。如果 `RabbitMQ` 没能处理这个消息，会回调你的一个 nack 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。

事务机制和 confirm 机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是 confirm 机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。

所以一般在生产者这块避免数据丢失，都是用 confirm 机制的。